##总结

JVM  内存结构和 Java 虚拟机的运行时区域有关；
Java（JMM） 内存模型和 Java 的并发编程有关。

==================================================================
虚拟机栈（Java Virtual Machine Stacks）
     
    每个线程拥有一个「虚拟机栈」，每个「虚拟机栈」拥有多个「栈帧」，
    而栈帧则对应着一个方法。每个「栈帧」包含局部变量表、操作数栈、动态链接、方法返回地址。方法运行结束则意味着该「栈帧」出栈。

   一个Java 方法执行的时候则创建一个「栈帧」并入栈「虚拟机栈」。
    调用结束则「栈帧」出栈，随之对应的线程也结束。
    
    每个栈帧包含四个区域：

1 局部变量表：基本数据类型、对象引用、retuenAddress 指向字节码的指针；
2 操作数栈
3 动态连接
4 返回地址

    即使只有一个 main 方法，都是以线程的方式运行，在运行的生命周期中，参与计算的数据会出栈与入栈，而「虚拟机栈」里面的每条数据就是「栈帧」。
====================================================================
本地方法栈（Native Method Stacks）
      跟虚拟机栈类似，区别在于前者是为 Java 方法服务，而本地方法栈是为 native 方法服务。
====================================================================
程序计数器（The PC Register）
     程序计数器是一块较小的内存空间，它的作用可以看作是当前线程所执行的字节码的行号指示器。这里面保存当前正在执行的 JVM 指令地址，即程序执行的进度。我们的程序在线程切换中运行，用这个知道这个线程已经执行到什么地方了。
======================================================================

方法区（Method Area）元空间
     存储每个 class 类的元数据信息，比如类的结构、运行时的常量池、字段、方法数据、方法构造函数以及接口初始化等特殊方法。

	元空间是在堆上么？

	答：不是在堆上分配的，而是在堆外空间分配，方法区就是在元空间中。

	字符串常量池在那个区域中？

	答：这个跟 JDK 不同版本不同区别，JDK 1.8 之前，元空间还没有出道成团，方法区被放在一个叫永久代的空间，而字符串常量就在此间。

	JDK 1.7 之前，字符串常量池也放在叫作永久带的空间。JDK 1.7 之后，字符串常量池从永久代挪到了堆上凑。

	所以，从 1.7 版本开始，字符串常量池就一直存在于堆上。
===========================================================================
堆（Heap）
       堆区域存储实例对象以及数组，通常是占用内存最大的一块也是数据共享的，比如 new Object() 就会生成一个实例；

Java 的对象可以分为基本数据类型和普通对象。

      对于普通对象来说，JVM 会首先在堆上创建对象，然后在其他地方使用的其实是它的引用。比如，把这个引用保存在虚拟机栈的局部变量表中。像 int[] 数组这样的内容，是在堆上分配的。数组并不是基本数据类型。

    对于基本数据类型来说（byte、short、int、long、float、double、char)，有两种情况：
       1. 当你在方法体内声明了基本数据类型的对象，它就会在栈上直接分配。（每个线程拥有一个虚拟机栈。）
       2.其他情况，通常在在堆上分配，逃逸分析的情况下可能会在栈分配。
=============================================================================
执行字节码的模块叫做执行引擎，执行引擎依靠程序计数器恢复线程切换。
本地内存包含元数据区域以及一些直接内存。
